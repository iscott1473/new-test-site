'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var parse = _interopDefault(require('posthtml-parser'));
var React = _interopDefault(require('react'));
var htmlEntities = require('html-entities');

function hypenColonToCamelCase(str) {
  // convert hypen and colon to camel case
  // color-profile -> colorProfile
  // xlink:role -> xlinkRole
  return str.replace(/(-|:)(.)/g, function (match, symbol, char) {
    return char.toUpperCase();
  });
}

// Based on https://github.com/reactjs/react-magic/blob/master/src/htmltojsx.js
function convertProperty(prop) {
  if (/^-ms-/.test(prop)) {
    // eslint-disable-next-line no-param-reassign
    prop = prop.substr(1);
  }

  return hypenColonToCamelCase(prop);
}

function convertValue(value) {
  // value can be converted to pixel automatically by converting it to number
  if (/^\d+$/.test(value)) {
    return Number(value);
  }

  return value.replace(/'/g, '"');
}

function convertStyle(styleStr) {
  var style = {};

  styleStr.split(';').filter(function (style) {
    var declaration = style.trim();
    return declaration !== '';
  }).forEach(function (declaration) {
    var rules = declaration.split(':');
    if (rules.length > 1) {
      var prop = convertProperty(rules[0].trim());
      //To handle url: attribute on style
      var val = convertValue(rules.slice(1).join(':').trim());
      style[prop] = val;
    }
  });

  return style;
}

/* global preval */
// only includes attribute that needs mapping (lowercase -> camelCase)
// credits: https://github.com/noraesae/react-attr-converter/blob/master/index.js
var attributeMap = { "for": "htmlFor", "class": "className", "acceptcharset": "acceptCharset", "accesskey": "accessKey", "allowfullscreen": "allowFullScreen", "allowtransparency": "allowTransparency", "autocomplete": "autoComplete", "autofocus": "autoFocus", "autoplay": "autoPlay", "cellpadding": "cellPadding", "cellspacing": "cellSpacing", "charset": "charSet", "classid": "classID", "classname": "className", "colspan": "colSpan", "contenteditable": "contentEditable", "contextmenu": "contextMenu", "crossorigin": "crossOrigin", "datetime": "dateTime", "enctype": "encType", "formaction": "formAction", "formenctype": "formEncType", "formmethod": "formMethod", "formnovalidate": "formNoValidate", "formtarget": "formTarget", "frameborder": "frameBorder", "hreflang": "hrefLang", "htmlfor": "htmlFor", "httpequiv": "httpEquiv", "inputmode": "inputMode",
  "keyparams": "keyParams", "keytype": "keyType", "marginheight": "marginHeight", "marginwidth": "marginWidth", "maxlength": "maxLength", "mediagroup": "mediaGroup", "minlength": "minLength", "novalidate": "noValidate", "radiogroup": "radioGroup", "readonly": "readOnly", "rowspan": "rowSpan", "spellcheck": "spellCheck", "srcdoc": "srcDoc", "srclang": "srcLang", "srcset": "srcSet", "tabindex": "tabIndex", "usemap": "useMap" };

// convert attr to valid react props
function mapAttribute() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return Object.keys(attrs).reduce(function (result, attr) {
    // ignore inline event attribute
    if (/^on.*/.test(attr)) {
      return result;
    }

    // Convert attribute to camelCase except data-* and aria-* attribute
    // https://facebook.github.io/react/docs/dom-elements.html
    var attributeName = attr;
    if (!/^(data|aria)-/.test(attr)) {
      attributeName = hypenColonToCamelCase(attr);
    }

    var name = attributeMap[attributeName] || attributeName;
    if (name === 'style') {
      result[name] = convertStyle(attrs.style);
    } else {
      result[name] = attrs[attr];
    }

    return result;
  }, {});
}

// eslint-disable-next-line no-use-before-define


var TABLE_ELEMENTS = ['table', 'tbody', 'thead', 'tfoot', 'tr'];

function transform(node, key, options) {
  var defaultMap = options.map._;

  if (typeof node === 'string') {
    // newline and space will be parsed as 'node' in posthtml-parser,
    // we can ignore it along with comment node
    var text = node.trim();
    if (/^<!--[\s\S]+-->/.test(text)) {
      return null;
    }

    var str = htmlEntities.AllHtmlEntities.decode(node);
    return defaultMap ? defaultMap(str) : str;
  }

  var tag = node.tag,
      attrs = node.attrs,
      content = node.content;

  var customElement = options.map[tag];

  // decode all attribute value
  if (attrs) {
    Object.keys(attrs).forEach(function (key) {
      attrs[key] = htmlEntities.AllHtmlEntities.decode(attrs[key]);
    });
  }

  var props = Object.assign({}, mapAttribute(attrs),
  // always set key because it's possible the html source contains
  // multiple elements
  { key: key });

  // style tag needs to preserve its children
  if (tag === 'style' && !customElement && !defaultMap) {
    props.dangerouslySetInnerHTML = { __html: content[0] };
    return React.createElement(tag, props, null);
  }

  // self closing component doesn't have children
  var children = content === undefined ? null : content.map(function (child, index) {
    if (TABLE_ELEMENTS.indexOf(tag) > -1 && typeof child == 'string') {
      child = child.trim();
      if (child === '') {
        return null;
      }
    }

    var childKey = key + '.' + index;
    return transform(child, childKey, options);
  }).filter(function (child) {
    return child !== null;
  });

  if (children && children.length === 0) {
    children = null;
  }

  if (customElement) {
    return React.createElement(customElement, props, children);
  }

  if (defaultMap) {
    return defaultMap(tag, props, children);
  }

  return React.createElement(tag, props, children);
}

function convertServer(html) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var opts = { map: options.map || {} };
  var ast = parse(html.trim());
  var components = ast.map(function (node, index) {
    return transform(node, index.toString(), opts);
  }).filter(function (node) {
    return node !== null;
  });

  if (components.length > 1) {
    return components;
  }

  return components[0];
}

module.exports = convertServer;
